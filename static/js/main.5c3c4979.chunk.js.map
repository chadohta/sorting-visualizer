{"version":3,"sources":["algorithms/MergeSort.js","algorithms/QuickSort.js","algorithms/HeapSort.js","algorithms/BubbleSort.js","components/info.jsx","components/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSort","mainArray","startIdx","endIdx","middleIdx","Math","floor","mainArrayIdx","arrayOneIdx","arrayTwoIdx","push","merge","getQuickSortAnimations","quickSort","low","high","j","pivot","i","type","barOne","barTwo","heightOne","heightTwo","swap","partition","temp","getHeapSortAnimations","heapSize","heapify","heapSort","largest","l","r","getBubbleSortAnimations","n","bubbleSort","Info","state","className","Component","SortingVisualizer","this","newArray","random","setState","document","querySelectorAll","forEach","button","disabled","unlockSortButtons","lockButtons","arrayBars","getElementsByClassName","barOneIdx","barTwoIdx","barOneStyle","style","barTwoStyle","color","setTimeout","backgroundColor","newHeight","height","unlockResetButtons","pivotBarIdx","pivotBarStyle","onClick","visualizeMergeSort","visualizeQuickSort","visualizeHeapSort","visualizeBubbleSort","map","value","index","key","reset","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.5c3c4979.chunk.js","sourcesContent":["export function getMergeSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    const auxiliaryArray = array.slice();\n    mergeSort(array, 0, array.length - 1, auxiliaryArray, animations);\n    return animations;\n}\n\nfunction mergeSort(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n    if (startIdx === endIdx) return;\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\n    mergeSort(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n    mergeSort(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n    merge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction merge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\n    let mainArrayIdx = startIdx;\n    let arrayOneIdx = startIdx;\n    let arrayTwoIdx = middleIdx + 1;\n    while (arrayOneIdx <= middleIdx && arrayTwoIdx <= endIdx) {\n        animations.push([arrayOneIdx, arrayTwoIdx]); // color change (comparing)\n        animations.push([arrayOneIdx, arrayTwoIdx]); // revert color \n\n        if (auxiliaryArray[arrayOneIdx] <= auxiliaryArray[arrayTwoIdx]) {\n            // value from arrayOne is smaller, set this number in main array\n            animations.push([mainArrayIdx, auxiliaryArray[arrayOneIdx]]);\n            mainArray[mainArrayIdx++] = auxiliaryArray[arrayOneIdx++];\n        } else {\n            // value from arrayTwo is smaller, set this number in main array\n            animations.push([mainArrayIdx, auxiliaryArray[arrayTwoIdx]]);\n            mainArray[mainArrayIdx++] = auxiliaryArray[arrayTwoIdx++];\n        }\n    }\n    while (arrayOneIdx <= middleIdx) {\n        animations.push([arrayOneIdx, arrayOneIdx]);\n        animations.push([arrayOneIdx, arrayOneIdx]);\n\n        // arrayTwo is empty, push the rest of arrayOne values to mainArray\n        animations.push([mainArrayIdx, auxiliaryArray[arrayOneIdx]]);\n        mainArray[mainArrayIdx++] = auxiliaryArray[arrayOneIdx++];\n    }\n    while (arrayTwoIdx <= endIdx) {\n        animations.push([arrayTwoIdx, arrayTwoIdx]);\n        animations.push([arrayTwoIdx, arrayTwoIdx]);\n\n        // arrayOne is empty, push the rest of arrayTwo values to mainArray\n        animations.push([mainArrayIdx, auxiliaryArray[arrayTwoIdx]]);\n        mainArray[mainArrayIdx++] = auxiliaryArray[arrayTwoIdx++];\n    }\n}","export function getQuickSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    quickSort(array, 0, array.length - 1, animations);\n    return animations;\n}\n\nfunction quickSort(array, low, high, animations) {\n    if (low >= high) { \n        return;\n    }\n    let j = partition(array, low, high, animations);\n    quickSort(array, low, j - 1, animations);\n    quickSort(array, j + 1, high, animations);\n}\n\nfunction partition(array, low, high, animations) {\n    let pivot = array[low];\n    let i = low;\n    let j = high;\n\n    // change color of pivot\n    animations.push({type: \"colorPivot\", barOne: low});\n\n    while (i < j) { \n        while (array[i] <= pivot) { \n            i++;\n        }\n        while (array[j] > pivot) { \n            j--;\n        }\n        if (i < j) { \n            // change color of bars you intend to swap + revert them after the swap\n            animations.push({type: \"foundBars\", barOne: i, barTwo: j});\n            animations.push({type: \"swapBars\", barOne: i, barTwo: j, heightOne: array[i], heightTwo: array[j]});\n            animations.push({type: \"revertColor\", barOne: i, barTwo: j});\n            swap(array, i, j);\n        }\n    }\n    // place pivot in correct place, change color of swaping + revert\n    animations.push({type: \"foundBars\", barOne: low, barTwo: j});\n    animations.push({type: \"swapBars\", barOne: low, barTwo: j, heightOne: array[low], heightTwo: array[j]});\n    animations.push({type: \"revertColor\", barOne: low, barTwo: j});\n    swap(array, low, j);\n    return j;\n}\n\nfunction swap(array, i, j) { \n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}","export function getHeapSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    heapSort(array, animations);\n    return animations;\n}\n\nfunction heapSort(array, animations) {\n    const heapSize = array.length;\n    // build max heap\n    for (let i = Math.floor(heapSize / 2 - 1); i >= 0; i--) {\n        heapify(array, heapSize, i, animations);\n    }\n    \n    // heap sort\n    for (let i = heapSize - 1; i >= 0; i--) { \n        swap(array, 0, i, animations);\n        // color bar that marks end of max heap and start of sorted array\n        animations.push({type: \"colorCutOffBar\", barOne: i});\n        if (i !== heapSize - 1) { \n            animations.push({type: \"colorSorted\", barOne: i + 1});\n        }\n        heapify(array, i, 0, animations)\n    }\n    animations.push({type: \"colorSorted\", barOne: 0});\n}\n\nfunction heapify(array, heapSize, i, animations) {\n    let largest = i; // initialize largest as root \n    let l = 2 * i + 1;\n    let r = 2 * i + 2;\n\n    // if left child is larger than root \n    if (l < heapSize && array[l] > array[largest]) {\n        largest = l;\n    }\n    // if right child is larger than largest so far \n    if (r < heapSize && array[r] > array[largest]) {\n        largest = r;\n    }\n\n    // if largest is not root \n    if (largest !== i) {\n        swap(array, i, largest, animations);\n        // recursively heapify the affected sub-tree \n        heapify(array, heapSize, largest, animations);\n    }\n}\n\nfunction swap(array, i, j, animations) {\n    animations.push({type: \"swapBars\", barOne: i, barTwo: j, heightOne: array[i], heightTwo: array[j]});\n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}\n","export function getBubbleSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    bubbleSort(array, animations);\n    return animations;\n}\n\nfunction bubbleSort(array, animations) { \n    let n = array.length;\n    for (let i = 1; i < n; i++) { \n        for (let j = 0; j < n - i; j++) { \n            animations.push({type: \"foundBars\", barOne: j, barTwo: j+1});\n            if (array[j] > array[j + 1]) { \n                swap(array, j, j + 1, animations);\n            }\n            animations.push({type: \"revertColor\", barOne: j, barTwo: j+1});\n        }\n        // color the last items in the array (sorted position)\n        // animations.push({type: \"colorSorted\", barOne: n - i });\n    }\n}\n\nfunction swap(array, i, j, animations) {\n    animations.push({type: \"swapBars\", barOne: i, barTwo: j, heightOne: array[i], heightTwo: array[j]});\n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}","import React, { Component } from 'react';\nimport '../styles/info.css';\n\nclass Info extends Component {\n    state = {}\n    render() {\n        return (\n            <div>\n                <h2> Sorting Algorithms </h2>\n                <p> This application visualizes various sorting algorithms. </p> \n                <p className=\"app-desc\">\n                    Below are descriptions of each algorithm implemented in this\n                    application.\n                </p>\n\n                <h3> Divide and Conquer </h3>\n                <p>\n                    Merge and Quick Sort are both \"divide and conquer\" algorithms and thus\n                    it's easier to understand how they work if we first discuss this term. \n                </p>\n                <p>\n                    Divide and Conquer essentially means to continuously break down the problem\n                    into smaller sub-problems until it is simple enough to solve easily. For\n                    sorting, that point would be when the entire group of bars is broken down into\n                    many sub-groups of individual bars. When there is only one bar in each group, \n                    all groups are technically sorted. These solutions are then combined to \n                    answer the original, much larger problem.\n                </p>\n\n                <div className=\"alg-description-1\">\n                    <h4> Merge Sort </h4>\n                    <p className=\"alg-des-italic\"> divide and conquer, stable </p>\n                    <p className=\"alg-des\">                        \n                        Merge Sort will divide the group of bars into many sub-groups \n                        containing one bar each. Again, since there is only one bar in each\n                        group, each group is technically sorted. Merge sort then\n                        merges the sorted sub-groups back together which eventually leads to one \n                        large group of bars that is now sorted!\n                    </p>\n                </div>\n                <div className=\"alg-description-1\">\n                    <h4> Quick Sort </h4>\n                    <p className=\"alg-des-italic\"> divide and conquer, not stable </p>\n                    <p className=\"alg-des\">\n                        Quick sort is similar to merge sort in that it is also a divide and \n                        conquor algorithm however quick sort actually sorts the bars\n                        while it's dividing (breaking down into sub-groups). \n                        \n                        The algorithm selects a pivot bar and essentially creates two sub-groups, \n                        one with bars smaller than the pivot and the other with bars larger than \n                        the pivot. It then does the same thing with the two sub-lists and so on \n                        until all bars are sorted.\n                    </p>\n                </div>\n                <div className=\"alg-description-1\">\n                    <h4> Heap Sort </h4>\n                    <p className=\"alg-des-italic\"> not stable </p>\n                    <p className=\"alg-des\">\n                        Heap Sort utilizes max heaps to find the largest bar in the group and\n                        then moves it to the end or the \"sorted section\". It continuous to do this\n                        until all bars are sorted.\n                    </p>\n                </div>\n                <div className=\"alg-description-1\">\n                    <h4> Bubble Sort </h4>\n                    <p className=\"alg-des-italic\"> stable </p>\n                    <p className=\"alg-des\">\n                        Bubble Sort continuously compares adjacent bars and swaps them if \n                        they are not in sorted order. This leads to the largest bars being pushed to the\n                        end and eventually all bars will be sorted. As you will see with \n                        the visualizer, bubble sort is very slow compared to the other algorithms.\n                    </p>\n                </div>\n\n                <h3> Stable vs. Not Stable </h3>\n                <p>\n                    Stability is concerned with how an algorithm handles equal elements \n                    (in this case, bars of the same size). To be stable means the algorithm\n                    will preserve the order in which the equivalent bars were in orginally.\n                </p>\n            </div>\n        );\n    }\n}\n\nexport default Info;","import React, { Component } from 'react';\nimport '../styles/SortingVisualizer.css';\nimport { getMergeSortAnimations } from '../algorithms/MergeSort';\nimport { getQuickSortAnimations } from '../algorithms/QuickSort';\nimport { getHeapSortAnimations } from '../algorithms/HeapSort';\nimport { getBubbleSortAnimations } from '../algorithms/BubbleSort';\nimport Info from './info'\n\nclass SortingVisualizer extends Component {\n    state = { \n        array: [],\n    }\n\n    componentDidMount() { \n        this.newArray();\n    }\n\n    newArray() { \n        const array = [];\n        const min = 10\n        const max = 500\n        for (let i = 0; i < 80; i++) { \n            array.push(Math.floor(min + Math.random() * (max - min + 1)));\n        }\n        this.setState({\n            array: array,\n        });\n    }\n\n    lockButtons() {\n        const buttons = document.querySelectorAll('button');\n        buttons.forEach((button) => {\n            button.disabled = true;\n        });\n    }\n\n    unlockSortButtons() {\n        const buttons = document.querySelectorAll('.sortBtn');\n        buttons.forEach((button) => {\n            button.disabled = false;\n        });\n    }\n\n    unlockResetButtons() {\n        const buttons = document.querySelectorAll('.resetBtn');\n        buttons.forEach((button) => {\n            button.disabled = false;\n        });\n    }\n\n    reset() { \n        this.newArray();\n        this.unlockSortButtons();\n    }\n\n    visualizeMergeSort() {\n        this.lockButtons();\n        const { array } = this.state;\n\n        const animations = getMergeSortAnimations(array);\n        for (let i = 0; i < animations.length; i++) {\n            const arrayBars = document.getElementsByClassName('array-bar');\n            const isColorChange = i % 3 !== 2;\n            if (isColorChange) {\n                const [barOneIdx, barTwoIdx] = animations[i];\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n                const color = i % 3 === 0 ? `rgb(${\"236, 77, 77\"})` : `rgb(${\"30, 199, 221\"})`;\n                setTimeout(() => {\n                    barOneStyle.backgroundColor = color;\n                    barTwoStyle.backgroundColor = color;\n                }, i * 10);\n            } else {\n                setTimeout(() => {\n                    const [barOneIdx, newHeight] = animations[i];\n                    const barOneStyle = arrayBars[barOneIdx].style;\n                    barOneStyle.height = `${newHeight}px`;\n                }, i * 10);\n            }\n        }\n        setTimeout(() => {\n            this.unlockResetButtons();\n        }, 10 * animations.length);\n    }\n\n    visualizeQuickSort() {\n        this.lockButtons();\n        const { array } = this.state;\n\n        const animations = getQuickSortAnimations(array);\n        for (let i = 0; i < animations.length; i++) {\n            const arrayBars = document.getElementsByClassName('array-bar');\n            const type = animations[i].type;\n            if (type === \"colorPivot\") { \n                const pivotBarIdx = animations[i].barOne;\n                const pivotBarStyle = arrayBars[pivotBarIdx].style;\n                setTimeout(() => {\n                    pivotBarStyle.backgroundColor = `rgb(${\"255, 145, 55\"})`;\n                }, i * 100);\n            } else if (type === \"swapBars\") { \n                const barOneIdx = animations[i].barOne;\n                const barTwoIdx = animations[i].barTwo;\n                const heightOne = animations[i].heightOne;\n                const heightTwo = animations[i].heightTwo;\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n                setTimeout(() => {\n                    barOneStyle.height = `${heightTwo}px`;\n                    barTwoStyle.height = `${heightOne}px`;\n                }, i * 100);\n            } else { //founds bars or revert colors\n                const color = type === \"foundBars\" ? `rgb(${\"236, 77, 77\"})` : `rgb(${\"30, 199, 221\"})`;\n                const barOneIdx = animations[i].barOne;\n                const barTwoIdx = animations[i].barTwo;\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n                setTimeout(() => {\n                    barOneStyle.backgroundColor = color;\n                    barTwoStyle.backgroundColor = color;\n                }, i * 100);\n            }\n        }\n        setTimeout(() => {\n            this.unlockResetButtons();\n        }, 100 * animations.length);\n    }\n\n    visualizeHeapSort() {\n        this.lockButtons();\n        const { array } = this.state;\n\n        const animations = getHeapSortAnimations(array);\n        for (let i = 0; i < animations.length; i++) {\n            const arrayBars = document.getElementsByClassName('array-bar');\n            const type = animations[i].type;\n            if (type === \"swapBars\") { \n                const barOneIdx = animations[i].barOne;\n                const barTwoIdx = animations[i].barTwo;\n                const heightOne = animations[i].heightOne;\n                const heightTwo = animations[i].heightTwo;\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n                setTimeout(() => {\n                    barOneStyle.height = `${heightTwo}px`;\n                    barTwoStyle.height = `${heightOne}px`;\n                }, i * 10);\n            } else { // \"colorCutOffBar or colorSorted\"\n                const color = type === \"colorCutOffBar\" ? `rgb(${\"236, 77, 77\"})` : `rgb(${\"30, 199, 221\"})`;\n                const barOneIdx = animations[i].barOne;\n                const barOneStyle = arrayBars[barOneIdx].style;\n                setTimeout(() => {\n                    barOneStyle.backgroundColor = color;\n                }, i * 10);\n            }\n        }\n        setTimeout(() => {\n            this.unlockResetButtons();\n        }, 10 * animations.length);\n    }\n\n    visualizeBubbleSort() {\n        this.lockButtons();\n        const { array } = this.state;\n\n        const animations = getBubbleSortAnimations(array);\n        for (let i = 0; i < animations.length; i++) {\n            const arrayBars = document.getElementsByClassName('array-bar');\n            const type = animations[i].type;\n            if (type === \"swapBars\") {\n                const barOneIdx = animations[i].barOne;\n                const barTwoIdx = animations[i].barTwo;\n                const heightOne = animations[i].heightOne;\n                const heightTwo = animations[i].heightTwo;\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n                setTimeout(() => {\n                    barOneStyle.height = `${heightTwo}px`;\n                    barTwoStyle.height = `${heightOne}px`;\n                }, i * 10);\n            } else { //founds bars or revert colors\n                const color = type === \"foundBars\" ? `rgb(${\"236, 77, 77\"})` : `rgb(${\"30, 199, 221\"})`;\n                const barOneIdx = animations[i].barOne;\n                const barTwoIdx = animations[i].barTwo;\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n                setTimeout(() => {\n                    barOneStyle.backgroundColor = color;\n                    barTwoStyle.backgroundColor = color;\n                }, i * 10);\n            }\n        }\n        setTimeout(() => {\n            this.unlockResetButtons();\n        }, 10 * animations.length);\n    }\n\n    render() { \n        const { array } = this.state;\n        \n        return ( \n            <div>\n                <h1> Sorting Visualizer </h1>\n                <button className=\"sortBtn\" onClick={() => this.visualizeMergeSort()}>Merge Sort</button>\n                <button className=\"sortBtn\" onClick={() => this.visualizeQuickSort()}>Quick Sort</button>\n                <button className=\"sortBtn\" onClick={() => this.visualizeHeapSort()}>Heap Sort</button>\n                <button className=\"sortBtn\" onClick={() => this.visualizeBubbleSort()}>Bubble Sort</button>\n\n                <div className=\"array-container\">\n                    {array.map((value, index) => (\n                        <div \n                            className=\"array-bar\" \n                            key={index} \n                            style={{\n                                height: `${value}px`,\n                            }}>\n                        </div>\n                    ))}\n                </div>\n\n                <button className=\"resetBtn\" onClick={() => this.reset()}>Reset</button>\n\n                <div className=\"info-wrapper\">\n                    <Info />\n                </div>\n\n            </div>\n         );\n    }\n}\n \nexport default SortingVisualizer;","import React from 'react';\nimport './App.css';\nimport SortingVisualizer from './components/SortingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}